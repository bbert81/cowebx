<!DOCTYPE html>
<html>
  	<head>
		<title>OpenCoweb Application with Persistence</title>
		<link href="http://fonts.googleapis.com/css?family=Amaranth:400,700" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="about.css" type="text/css" />
		<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
		<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
  	</head>
	<body onload="prettyPrint()">
		<div class="title">OpenCoweb Application with Persistence</div>
		<div class="entry titleSub">A guide for adding persistence to an OpenCoweb application. You might be interested in seeing our tutorial on developing a <a href="about.html">tree structured</a> OpenCoweb application first.
		</div>
	
		<div class="subTitle">1. The OpenCoweb Moderator</div>
		<div class="entry">
			The OpenCoweb framework allows application programmers to write a custom Java class that lives on the server and receives remote sync events. The moderator class is responsible for honoring all remote sync events, and is responsible for sending its application state to new session clients (as opposed to other browser clients sending their application state via <a href="http://opencoweb.org/ocwdocs/js/extra.html?highlight=onstaterequest#CowebWrapper.onStateRequest">onStateRequest</a>.
			<br /><br />
			The cool feature is that even after all browser clients have left the session, the moderator instance will continue to persist on the server (including whatever application state it has managed). Whenever a new client open the application with the same session key, the application will be loaded from the moderator state. Every collaborative session remains persistent on the server.
		</div>
		<br /><br />
		<div class="subTitle">2. The SessionModerator Class</div>
		<div class="entry">
			Below are the extendable methods of <b>DefaultSessionModerator</b> (which itself extends <b>SessionModerator</b>). The most interesting method to override will likely be <b>onSync</b>. For a more complete documentation, see the <a href="#">SessionModerator javadocs</a>.
		</div>
<pre class="prettyprint code">
import org.cometd.bayeux.Message;
import org.cometd.bayeux.server.ServerSession;
import java.util.Map;

public boolean onSync(Map&lt;String, Object&gt; data);

public Map&lt;String, Object&gt; getLateJoinState();

public boolean canClientJoinSession(ServerSession client);

public void onClientJoinSession(ServerSession client);

public void onClientLeaveSession(ServerSession client);

public boolean canClientSubscribeService(ServerSession client);

public boolean canClientMakeServiceRequest(ServerSession client, Message botMessage);

public void onServiceResponse(Message botResponse);

public void onSessionEnd();
</pre>
		<br /><br />
		<div class="subTitle">3. Turning the Moderator On</div>
		<div class="entry">
			
<pre class="prettyprint code">
{
  // Full java classname of moderator class
  "sessionModerator"   : "org.coweb.CotreeModerator",
  // The moderator instance will send the full application state to new clients.
  "moderatorIsUpdater" : true,
  // Events are transformed (moderatorIsUpdater automatically implies operationEngine anyway)
  "operationEngine"    : true,
  // An array of bot configs (optional)
  "bots": []
}
</pre>
		</div>
		<br /><br />
		<div class="subTitle">4. Adding a Moderator to CoTree</div>
		<div class="entry">
		</div>
	<br /><br />
	<div class="subTitle">3. Celebrate</div>
	<div class="entry">
		That's it. All events now go through your Moderator class, allowing you to keep state server-side however you see fit for your application, whether it's maintaining a complex object, as in the Cotree demo, or pushing syncs into a remote database. Either way, when a new member comes into the session, your Moderator can give that user whatever state you choose.
	</div>
<br /><br />
</body>
</html>
