//
// Unmanaged OpenAjax Hub implementation of the ListenerInterface.
//
// Copyright (c) The Dojo Foundation 2011. All Rights Reserved.
// Copyright (c) IBM Corporation 2008, 2011. All Rights Reserved.
//
/*global define*/
define([
    'coweb/topics',
    'coweb/jsoe/OperationEngine',
    'org/OpenAjax'
], function(topics, OperationEngine, OpenAjax) {    
    
    var listener = function() {
        this._paused = false;
        this._incomingPausedBuffer = [];
    };
    var proto = listener.prototype;

    /**
     * Called by the session when a coweb event is received from a remote app.
     * Processes the data in the local operation engine if required before 
     * publishing it on the local Hub. 
     *
     * @param {String} topic Topic name (topics.SYNC.**)
     * @param {String} value JSON-encoded operation value
     * @param {String|null} type Operation type
     * @param {Number} position Operation linear position
     * @param {Number} site Unique integer ID of the sending site
     * @param {Number[]} sites Context vector as an array of integers
     */
    proto.syncInbound = function(topic, value, type, position, site, sites, order) {
        var op, event;
        // console.debug('UnmanagedHubListener.syncInbound topic: %s, value: %s, type: %s, position: %s, site: %d, sites: %s', 
        //     topic, value, type || 'null', position, site, sites ? sites.toString() : 'null');
        if(this._paused && (type != null)) {
            this._incomingPausedBuffer.push([topic, value, type, position,
                                             site, sites, order]);
            return;
        }

        // check if the event has a context and non-null type
        if(sites && type) {
            // treat event as a possibly conflicting operation
            try {
                op = this._engine.push(false, topic, value, type, position, 
                    site, sites, order);
            } catch(e) {
                console.warn('UnmanagedHubListener: failed to push op into engine ' +
                    e.message);
                // @todo: we're out of sync now probably, fail the session?
                return;
            }
            // discard null operations; they should not be sent to app
            // according to op engine
            if(op === null) {return;}
            // use newly computed value and position
            value = op.value;
            position = op.position;
        } else if(site === this._engine.siteId) {
            // op was echo'ed from server for op engine, but type null means
            // op engine doesn't care about this message anyway so drop it
            return;
        }

        // value is always json-encoded to avoid ref sharing problems with ops
        // stored inside the op engine history buffer, so decode it and
        // pack it into a hub event
        event = {
            position : position,
            type : type,
            value : JSON.parse(value),
            site : site
        };

        // publish on local hub
        this._mutex = true;
        try {
            OpenAjax.hub.publish(topic, event);
        } catch(z) {
            console.warn('UnmanagedHubListener: failed to deliver incoming event ' + 
                topic + '(' + z.message + ')');
        }
        this._mutex = false;
    };

    /**
     * Called when an CollabInterface publishes a cooperative event on the 
     * local Hub. Processes the data in the local operation engine if required 
     * before forwarding it to the session.
     * 
     * @private
     * @param {String} topic Topic name (topics.SYNC.**)
     * @param {Object} event Cooperative event to send
     */
    proto._syncOutbound = function(topic, event) {
        // if the mutex is held, we're broadcasting and shouldn't be 
        // getting any additional events back, EVER!
        // (all other events will be generated by the same broadcast 
        // at other locations so we NEVER have to ship them)
        // assumes synchronous hub operation
        // stop now if we have no engine
        if(this._mutex || !this._engine) {
            return;
        }

        // unpack event data; be sure to json encode the value before pushing
        // into op engine to avoid ref sharing with the operation history
        var position = event.position,
            type = event.type,
            value = JSON.stringify(event.value),
            op = null,
            sites = null,
            msg,
            sent,
            err;

        if(type !== null) {   
            // build operation
            try {
                op = this._engine.createOp(true, topic, value, type, position);
                sites = op.contextVector.sites;
            } catch(e) {
                console.warn('UnmanagedHubListener: bad type "' + type +
                    '" on outgoing event; making null');
                type = null;
            }   
        }

        // console.debug('UnmanagedHubListener._syncOutbound topic: %s, value: %s, type: %s, position: %s, sites: %s', 
        // topic, value, type || 'null', position, sites ? sites.toString() : 'null');
        
        // post to client
        try {
            sent = this._bridge.postSync(topic, value, type, position, sites);
        } catch(x) {
            // ignore if can't post
            err = x;
            sent = false;
            console.warn('UnmanagedHubListener: failed to send hub event ' + 
                x.message);
        }
        if(sent && type !== null) {
            // add local event to engine, but only if it was really sent
            // yes, the local state changed, but it's better to keep the
            // context vector in the engine consistent than to track an
            // event we never sent
            this._engine.pushLocalOp(op);
            // we have to allow purges after sending even one event in 
            // case this site is the only one in the session for now
            this._shouldPurge = true;
        } else if(err) {
            // throw error back to the caller
            throw err;
        }
    };
    
    /**
     * Pause incoming operations from being applied. Puts all operations in a
     * buffer to be applied later when we resume.
     *
     * @private
     */
    proto._pause = function() {
        if(!this._paused) {
            this._paused = true;
            this._incomingPausedBuffer = [];
        }
    };

    /**
     * Resume syncing operations and apply the incoming operations that have
     * been buffered while we were paused.
     *
     * @private
     */
    proto._resume = function() {
        var i, len;
        if(this._paused) {
            this._paused = false;
            for(i = 0, len = this._incomingPausedBuffer.length; i < len; i++) {
                this.syncInbound.apply(this, this._incomingPausedBuffer[i]);
            }
        }
    }

    return listener;
});